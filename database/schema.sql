-- =============================================================================
-- MILOW SUPABASE COMBINED SCHEMA
-- Generated by merging:
-- 1. apps/driver/supabase_schema.sql (Base)
-- 2. supabase_migration_rbac.sql (RBAC & Messaging)
-- 3. supabase_grant_driver_permissions.sql (Policy Updates)
-- 4. supabase_update_profiles_schema.sql (Profile Expansions)
-- 5. supabase_indexes.sql (Performance)
-- 6. companies table (fetched from DB)
-- =============================================================================

-- ============================================
-- 1. ENUMS & CONSTANTS
-- ============================================

-- ============================================
-- 2. TABLES
-- ============================================

-- 2.1 COMPANIES
create table if not exists public.companies (
    id uuid not null default gen_random_uuid() primary key,
    name text not null,
    address text,
    city text,
    state text,
    zip_code text,
    country text,
    phone text,
    email text,
    website text,
    logo_url text,
    plan text default 'free'::text,
    created_at timestamp with time zone default now(),
    updated_at timestamp with time zone default now()
);

-- 2.2 PROFILES (Consolidated)
create table if not exists public.profiles (
    id uuid references auth.users on delete cascade not null primary key,
    email text,
    full_name text,
    
    -- RBAC & Verification
    role text default 'pending' check (role in ('admin', 'dispatcher', 'driver', 'safetyOfficer', 'assistant', 'pending')),
    is_verified boolean default false,
    
    -- Contact & Address
    phone text,
    street text,
    city text,
    state_province text,
    postal_code text,
    country text,
    address text, -- Legacy/Full address string
    
    -- Driver Specifics
    date_of_birth date,
    license_number text,
    license_type text,
    citizenship text,
    fast_id text,
    
    -- Company Relation
    company_id uuid references public.companies(id),
    company_name text, -- De-normalized or Legacy
    
    -- System
    avatar_url text,
    fcm_token text,
    target_admin_email text,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Optional comments
COMMENT ON COLUMN profiles.street IS 'Street address of the driver';
COMMENT ON COLUMN profiles.city IS 'City of the driver';
COMMENT ON COLUMN profiles.state_province IS 'State or Province of the driver';
COMMENT ON COLUMN profiles.postal_code IS 'ZIP or Postal code';
COMMENT ON COLUMN profiles.date_of_birth IS 'Driver date of birth';
COMMENT ON COLUMN profiles.license_number IS 'Driver license number';
COMMENT ON COLUMN profiles.license_type IS 'Class or type of driver license';
COMMENT ON COLUMN profiles.citizenship IS 'Citizenship country';
COMMENT ON COLUMN profiles.fast_id IS 'FAST card ID for border crossing';


-- 2.3 TRIPS
create table if not exists public.trips (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references auth.users not null,
    company_id uuid references public.companies(id), -- Inferred relation
    trip_number text not null,
    truck_number text not null,
    trailers text[] default '{}',
    trip_date timestamptz not null,
    pickup_locations text[] not null,
    delivery_locations text[] not null,
    start_odometer numeric,
    end_odometer numeric,
    distance_unit text not null default 'mi',
    border_crossing text,
    notes text,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on column trips.border_crossing is 'Optional border crossing location (e.g., Windsor-Detroit, Laredo)';


-- 2.4 FUEL ENTRIES
create table if not exists public.fuel_entries (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references auth.users not null,
    company_id uuid references public.companies(id), -- Inferred relation
    fuel_date timestamptz not null,
    fuel_type text not null check (fuel_type in ('truck', 'reefer')),
    truck_number text,
    reefer_number text,
    location text,
    odometer_reading numeric,
    reefer_hours numeric,
    fuel_quantity numeric not null,
    price_per_unit numeric not null,
    fuel_unit text not null default 'gal',
    distance_unit text not null default 'mi',
    currency text not null default 'USD',
    
    -- DEF
    def_quantity numeric default 0,
    def_price numeric default 0,
    def_from_yard boolean default false,

    created_at timestamptz default now(),
    updated_at timestamptz default now()
);


-- 2.5 MESSAGES
create table if not exists public.messages (
    id uuid default gen_random_uuid() primary key,
    sender_id uuid references public.profiles(id),
    receiver_id uuid references public.profiles(id),
    content text,
    is_read boolean default false,
    created_at timestamptz default now()
);


-- 2.6 NOTIFICATIONS
create table if not exists public.notifications (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references public.profiles(id) on delete cascade,
    type text not null, -- 'company_invite', 'message', 'system'
    title text,
    body text,
    data jsonb,
    is_read boolean default false,
    created_at timestamptz default now()
);


-- 2.7 APP VERSION
create table if not exists public.app_version (
    id bigint generated always as identity primary key,
    platform text not null,
    latest_version text not null,
    download_url text not null,
    changelog text,
    min_supported_version text,
    is_critical boolean default false,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
create unique index if not exists app_version_platform_idx on app_version (platform);


-- ============================================
-- 3. ENABLE RLS
-- ============================================
alter table public.companies enable row level security;
alter table public.profiles enable row level security;
alter table public.trips enable row level security;
alter table public.fuel_entries enable row level security;
alter table public.messages enable row level security;
alter table public.notifications enable row level security;
alter table public.app_version enable row level security;


-- ============================================
-- 4. FUNCTIONS & TRIGGERS
-- ============================================

-- 4.1 Get Role Helper
create or replace function public.get_my_claim_role()
returns text as $$
begin
  return coalesce((auth.jwt() -> 'app_metadata' ->> 'role'), 'pending');
end;
$$ language plpgsql stable security definer;

-- 4.2 Handle New User
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, role, is_verified, avatar_url)
  values (
    new.id, 
    new.email, 
    new.raw_user_meta_data->>'full_name',
    coalesce(new.raw_user_meta_data->>'role', 'pending'), 
    (coalesce(new.raw_user_meta_data->>'role', 'pending') = 'admin'),
    coalesce(new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'picture')
  );
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- 4.3 Sync User Role to Metadata
create or replace function public.sync_user_role()
returns trigger as $$
begin
  update auth.users
  set raw_app_meta_data = 
      jsonb_set(
        coalesce(raw_app_meta_data, '{}'::jsonb),
        '{role}',
        to_jsonb(new.role)
      )
  where id = new.id;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_profile_role_change on public.profiles;
create trigger on_profile_role_change
  after insert or update of role on public.profiles
  for each row
  execute procedure public.sync_user_role();


-- 4.4 Protect Sensitive Fields (Admin Only)
create or replace function public.protect_sensitive_profile_fields()
returns trigger as $$
declare
  v_current_role text;
begin
  if (new.role is distinct from old.role) or (new.is_verified is distinct from old.is_verified) then
    select role into v_current_role from public.profiles where id = auth.uid();
    if v_current_role is distinct from 'admin' then
       raise exception 'Unauthorized: Only admins can change user roles or verification status.';
    end if;
  end if;
  return new;
end;
$$ language plpgsql security definer;
-- Trigger typically attached via separate migration if needed, implicitly required for security.


-- 4.5 Notify on Message
create or replace function public.notify_on_message()
returns trigger as $$
begin
  insert into public.notifications (user_id, type, title, body, data)
  values (
    new.receiver_id,
    'message',
    'New Message',
    substring(new.content from 1 for 100),
    jsonb_build_object('message_id', new.id, 'sender_id', new.sender_id)
  );
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_message_created on public.messages;
create trigger on_message_created
  after insert on public.messages
  for each row execute procedure public.notify_on_message();


-- 4.6 Notify on Verification
create or replace function public.notify_on_verification()
returns trigger as $$
declare
  v_admin_name text;
begin
  if old.is_verified = false and new.is_verified = true then
    select full_name into v_admin_name from public.profiles where id = auth.uid();
    insert into public.notifications (user_id, type, title, body, data)
    values (
      new.id,
      'company_invite',
      'Verification Request',
      'Admin ' || coalesce(v_admin_name, 'Unknown') || ' has verified your ID.',
      jsonb_build_object('admin_id', auth.uid(), 'admin_name', v_admin_name)
    );
  end if;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_profile_verified_notify on public.profiles;
create trigger on_profile_verified_notify
  after update on public.profiles
  for each row execute procedure public.notify_on_verification();


-- ============================================
-- 5. RLS POLICIES
-- ============================================

-- PROFILES
drop policy if exists "Public profiles are viewable by everyone." on profiles;
drop policy if exists "Admins can view all profiles" on profiles;
create policy "Admins can view all profiles" on profiles 
  for select to authenticated 
  using (auth.uid() = id or public.get_my_claim_role() = 'admin');

drop policy if exists "Users can update own profile" on profiles;
create policy "Users can update own profile" on profiles 
  for update to authenticated 
  using (auth.uid() = id);

drop policy if exists "Admins can update all profiles" on profiles;
create policy "Admins can update all profiles" on profiles 
  for update to authenticated 
  using (public.get_my_claim_role() = 'admin');


-- TRIPS (Updated Policy)
drop policy if exists "Users can view own trips" on trips;
create policy "Users can view own trips" on trips 
  for select to authenticated using (auth.uid() = user_id);

drop policy if exists "Users can insert own trips" on trips;
create policy "Users can insert own trips" on trips 
  for insert to authenticated with check (auth.uid() = user_id);

drop policy if exists "Users can update own trips" on trips;
create policy "Users can update own trips" on trips 
  for update to authenticated using (auth.uid() = user_id);

drop policy if exists "Users can delete own trips" on trips;
create policy "Users can delete own trips" on trips 
  for delete to authenticated using (auth.uid() = user_id);


-- FUEL ENTRIES (Updated Policy)
drop policy if exists "Users can view own fuel entries" on fuel_entries;
create policy "Users can view own fuel entries" on fuel_entries 
  for select to authenticated using (auth.uid() = user_id);

drop policy if exists "Users can insert own fuel entries" on fuel_entries;
create policy "Users can insert own fuel entries" on fuel_entries 
  for insert to authenticated with check (auth.uid() = user_id);

drop policy if exists "Users can update own fuel entries" on fuel_entries;
create policy "Users can update own fuel entries" on fuel_entries 
  for update to authenticated using (auth.uid() = user_id);

drop policy if exists "Users can delete own fuel entries" on fuel_entries;
create policy "Users can delete own fuel entries" on fuel_entries 
  for delete to authenticated using (auth.uid() = user_id);


-- MESSAGES
drop policy if exists "Users can view own messages" on messages;
create policy "Users can view own messages" on messages 
  for select using (auth.uid() = sender_id or auth.uid() = receiver_id);

drop policy if exists "Users can send messages" on messages;
create policy "Users can send messages" on messages 
  for insert with check (auth.uid() = sender_id);


-- NOTIFICATIONS
drop policy if exists "Users can view own notifications" on notifications;
create policy "Users can view own notifications" on notifications 
  for select using (auth.uid() = user_id);

drop policy if exists "Admins can create notifications" on notifications;
create policy "Admins can create notifications" on notifications 
  for insert with check (public.get_my_claim_role() = 'admin' or auth.uid() = user_id);

drop policy if exists "Users can delete own notifications" on notifications;
create policy "Users can delete own notifications" on notifications 
  for delete using (auth.uid() = user_id);

drop policy if exists "Users can update own notifications" on notifications;
create policy "Users can update own notifications" on notifications 
  for update using (auth.uid() = user_id);


-- APP VERSION
create policy "Allow public read access" on app_version for select using (true);


-- ============================================
-- 6. INDEXES
-- ============================================
create index if not exists idx_messages_sender_id on public.messages(sender_id);
create index if not exists idx_messages_receiver_id on public.messages(receiver_id);
create index if not exists idx_notifications_user_id on public.notifications(user_id);
create index if not exists idx_notifications_is_read on public.notifications(is_read);
create index if not exists trips_user_id_idx on trips(user_id);
create index if not exists trips_trip_date_idx on trips(trip_date desc);
create index if not exists fuel_entries_user_id_idx on fuel_entries(user_id);
create index if not exists fuel_entries_fuel_date_idx on fuel_entries(fuel_date desc);


-- ============================================
-- 7. STORAGE BUCKETS (AVATARS)
-- ============================================
insert into storage.buckets (id, name, public) values ('avatars', 'avatars', true)
on conflict (id) do nothing;

create policy "Public read for avatars" on storage.objects for select using ( bucket_id = 'avatars' );
create policy "Users can upload their avatars" on storage.objects for insert with check ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] );
create policy "Users can update their avatars" on storage.objects for update using ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] );
create policy "Users can delete their avatars" on storage.objects for delete using ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] );
-- TRUCKS TABLE
create table if not exists public.trucks (
    id uuid default gen_random_uuid() primary key,
    company_id uuid references public.companies(id) not null,
    truck_number text not null,
    vehicle_type text not null,
    license_plate text,
    license_province text,
    vin_number text not null,
    dot_number text,
    insurance_policy text,
    terminal_address text, 
    created_by uuid references auth.users(id),
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- TRUCK DOCUMENTS TABLE
create table if not exists public.truck_documents (
    id uuid default gen_random_uuid() primary key,
    truck_id uuid references public.trucks(id) on delete cascade not null,
    company_id uuid references public.companies(id) not null, -- Denormalized for easier RLS
    document_type text not null, -- 'Registration', 'Insurance', 'Inspection', 'Other'
    file_path text not null,
    expiry_date date,
    notes text,
    created_at timestamptz default now()
);

-- ENABLE RLS
alter table public.trucks enable row level security;
alter table public.truck_documents enable row level security;

-- POLICIES FOR TRUCKS
create policy "Company members can view trucks"
  on public.trucks for select using (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

create policy "Company members can insert trucks"
  on public.trucks for insert with check (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

create policy "Company members can update trucks"
  on public.trucks for update using (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

create policy "Company members can delete trucks"
  on public.trucks for delete using (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

-- POLICIES FOR TRUCK DOCUMENTS
create policy "Company members can view truck documents"
  on public.truck_documents for select using (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

create policy "Company members can insert truck documents"
  on public.truck_documents for insert with check (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

create policy "Company members can update truck documents"
  on public.truck_documents for update using (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

create policy "Company members can delete truck documents"
  on public.truck_documents for delete using (
    company_id in (select company_id from public.profiles where id = auth.uid())
  );

-- STORAGE for Truck Documents
insert into storage.buckets (id, name, public) values ('truck_documents', 'truck_documents', false)
on conflict (id) do nothing;

create policy "Company members can view truck documents storage"
  on storage.objects for select using (
    bucket_id = 'truck_documents' and
    (storage.foldername(name))[1] in (
       select company_id::text from public.profiles where id = auth.uid()
    )
  );

create policy "Company members can upload truck documents storage"
  on storage.objects for insert with check (
    bucket_id = 'truck_documents' and
    (storage.foldername(name))[1] in (
       select company_id::text from public.profiles where id = auth.uid()
    )
  );

create policy "Company members can delete truck documents storage"
  on storage.objects for delete using (
    bucket_id = 'truck_documents' and
    (storage.foldername(name))[1] in (
       select company_id::text from public.profiles where id = auth.uid()
    )
  );

-- TRIGGER to auto-set company_id on trucks
create or replace function public.set_truck_company_id()
returns trigger as $$
begin
  if new.company_id is null then
    select company_id into new.company_id from public.profiles where id = auth.uid();
  end if;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists set_truck_company_id_trigger on public.trucks;
create trigger set_truck_company_id_trigger
  before insert on public.trucks
  for each row execute procedure public.set_truck_company_id();

-- TRIGGER to auto-set company_id on truck_documents
create or replace function public.set_truck_doc_company_id()
returns trigger as $$
begin
  if new.company_id is null then
    select company_id into new.company_id from public.profiles where id = auth.uid();
  end if;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists set_truck_doc_company_id_trigger on public.truck_documents;
create trigger set_truck_doc_company_id_trigger
  before insert on public.truck_documents
  for each row execute procedure public.set_truck_doc_company_id();
