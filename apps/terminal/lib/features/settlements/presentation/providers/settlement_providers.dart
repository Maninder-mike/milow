import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../domain/models/driver_pay_config.dart';
import '../../domain/models/driver_settlement.dart';
import '../../domain/models/settlement_item.dart';
import '../../data/repositories/settlement_repository.dart';

part 'settlement_providers.g.dart';

@riverpod
SettlementRepository settlementRepository(Ref ref) {
  return SettlementRepository(Supabase.instance.client);
}

@riverpod
Future<DriverPayConfig?> driverPayConfig(Ref ref, String driverId) {
  return ref.watch(settlementRepositoryProvider).getPayConfig(driverId);
}

@riverpod
Future<List<DriverSettlement>> driverSettlements(Ref ref, String driverId) {
  return ref.watch(settlementRepositoryProvider).fetchSettlements(driverId);
}

@riverpod
Future<DriverSettlement> settlementDetails(Ref ref, String settlementId) {
  return ref
      .watch(settlementRepositoryProvider)
      .getSettlementDetails(settlementId);
}

@riverpod
Future<List<Map<String, dynamic>>> unsettledLoads(Ref ref, String driverId) {
  return ref
      .watch(settlementRepositoryProvider)
      .discoverUnsettledLoads(driverId);
}

@riverpod
Future<List<Map<String, dynamic>>> unsettledFuel(Ref ref, String driverId) {
  return ref
      .watch(settlementRepositoryProvider)
      .discoverUnsettledFuel(driverId);
}

@riverpod
class SettlementController extends _$SettlementController {
  @override
  FutureOr<void> build() {}

  Future<String> createSettlement({
    required String driverId,
    required DateTime startDate,
    required DateTime endDate,
    required List<SettlementItem> items,
    String? notes,
  }) async {
    state = const AsyncValue.loading();
    try {
      final repository = ref.read(settlementRepositoryProvider);

      double totalEarnings = 0;
      double totalDeductions = 0;

      for (final item in items) {
        if (item.amount > 0) {
          totalEarnings += item.amount;
        } else {
          totalDeductions += item.amount.abs();
        }
      }

      final settlement = DriverSettlement(
        id: '', // Will be generated by DB
        driverId: driverId,
        status: SettlementStatus.draft,
        startDate: startDate,
        endDate: endDate,
        totalEarnings: totalEarnings,
        totalDeductions: totalDeductions,
        netPayout: totalEarnings - totalDeductions,
        notes: notes,
      );

      final id = await repository.createSettlement(settlement, items);
      ref.invalidate(driverSettlementsProvider(driverId));
      state = const AsyncValue.data(null);
      return id;
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }

  Future<void> updateStatus(
    String settlementId,
    String driverId,
    SettlementStatus status,
  ) async {
    state = const AsyncValue.loading();
    try {
      await ref
          .read(settlementRepositoryProvider)
          .updateSettlementStatus(settlementId, status);
      ref.invalidate(driverSettlementsProvider(driverId));
      ref.invalidate(settlementDetailsProvider(settlementId));
      state = const AsyncValue.data(null);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      rethrow;
    }
  }
}
